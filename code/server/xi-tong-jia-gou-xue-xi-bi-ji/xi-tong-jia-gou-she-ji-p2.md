# 系统架构设计 P2

### 信息系统基础知识

#### 信息系统基础知识

**信息系统的定义**

组成：

1. 机软硬件
2. 网络和通信设备
3. 信息资源
4. 用户
5. 规章制度

信息系统的功能有：

1. 输入
2. 存储
3. 处理
4. 输出
5. 控制

理查德·诺兰（Richard L. Nolan）将信息系统的发展道路划分为 6个阶段

1. 初始
2. 传播
3. 控制
4. 集成
5. 数据管理
6. 成熟

**信息系统的分类**

1. 业务（数据）处理系统
2. 管理信息系统
3. 决策支持系统
4. 专家系统
5. 办公自动化系统
6. 综合性信息系统

**信息系统的生命周期**

1. 产生
2. 开发
3. 运行
4. 消亡

**信息系统建设原则**

1. 高层管理人员介入原则
2. 用户参与开发原则
3. 自顶向下规划原则
4. 工程化原则等

**信息系统的开发方法**

1. 结构化方法
2. 原型法
3. 面向对象方法
4. 面向服务的方法
5. 敏捷方法
6. 构件化开发方法

**原型法**

以根据用户的**初步需求利用系统工具快速建立一个系统模型**，与**用户交流**。

按功能划分：

1. 水平原型：行为原型，**用于界面**。细化需求但并未实现功能。
2. 垂直原型：结构化原型，用**于复杂算法的实现**，实现了部分功能。

按最终结果划分：

1. 抛弃式：探索式原型，**解决需求不确定性、二义性、不完整性、含糊性**等。
2. 演化式：**逐步演化为最终系统**，用于易于升级和优化的场合，适用于 Web项目。

**构件化开发方法**

基于构件/组件（Component）的软件开发是**解决复杂环境下软件规模与复杂性的一种手段**。

构件并非一定包含类，一个类元素只能属于一个构件。

构件的获取方式有：

1. 从**现有构件中获得**符合要求的构件，直接使用或作适应性修改，得到可复用的构件。
2. 通过遗留工程（Legacy Engineering），**将具有潜在复用价值的构件提取出来**，得到可复用的构件。
3. 从市场上**购买**现成的商业构件。
4. **开发新的符合要求的构件**。获取到的构件可以存放到构件库中，根据需求裁剪使用。

**构件的分类方式**

**关键字分类法**

关键字分类法将**应用领域**的概念按照**从抽象到具体的顺序逐次分解为树型或有向无回路图结构**，每个概念用一个描述性的关键字表示。

**刻面分类法**

刻面分类法定义若干用于**刻画构件特征**的“刻面”，每个面包含若干概念，这些概念描述构件在刻面上的特征。刻面可以描述构件执行的功能、被操作的数据、构件应用的语境或其他特征。

**超文本方法**

所有构件必须辅以详尽的功能或行为说明文档；说明中出现的重要概念或构件以网状链接方式相互连接；检索者在阅读文档的过程中可按照人类的**联想思维方式任意跳转**到包含相关概念或构件的文档；全文检索系统将用户给出的关键字与说明文档中的文字进行匹配，实现构件的浏览式检索。

构件检索的方式也可以分为：基于关键字的检索、刻面检索法、超文本检索法。

**面向服务的方法**

面向服务的方法是在面向对象方法的基础上发展起来的，**对于跨构件的功能调用，则采用接口的形式暴露出来**。进一步将接口的定义与实现进行解耦，则催生了服务和面向服务（Service-Oriented，SO）的开发方法。

**敏捷方法**

敏捷方法是一种**以人为核心、迭代、循序渐进**的开发方法。

主要的特征 ：

1. 敏捷方法是“适应型”而非“预设型”。
2. 敏捷方法是“面向人的”而非“面向过程的”。

核心思想主要有以下 3点：

1. 敏捷方法是适应型，而非可预测型。
2. 敏捷方法以人为本，而非以过程为本。
3. 属于迭代增量式的开发过程。

#### 信息化的典型应用

**TPS和 EDPS**

业务处理系统（Transaction Processing System，TPS）或电子数据处理系统（Electronic Data Processing System，EDPS）是信息化的典型应用。

业务系统数据处理周期分为 5个阶段：

1. 数据输入
2. 数据处理
3. 数据库的维护
4. 文件报表的生成
5. 查询处理

数据处理方式：

1. 批处理（Batch Processing）
2. 联机事务处理（OnLine Transaction Processing，OLTP）

**管理信息系统**

管理信息系统（Manage Information System，MIS）是在 TPS基础上发展的高度集成化的人机信息系统，用于**企业整体的某些管理**和**业务层面的管理决策**。

MIS系统的上层是子系统和功能，底层是各个过程，功能由过程组合实现。

一个 MIS系统可以用一个功能/层次矩阵表示。

7个子系统：

1. 销售市场子系统
2. 生产子系统
3. 后勤子系统
4. 人事子系统
5. 财务和会计子系统
6. 信息处理子系统
7. 高层管理子系统

**决策支持系统**

两种定义：

1.  DSS是一个由**语言系统、知识系统和问题处理**系统 3个互相关联的部分组成的，基于计算机的系统。

    特征如下：

    1. 数据和模型是 DSS的主要资源。
    2. 用来支援用户作决策。
    3. 主要用于解决半结构化及非结构化问题。
    4. 作用在于提高决策的有效性而不是提高决策的效率。
2.  DSS是一个**交互式的、灵活的、适应性强**的基于计算机的信息系统。

    特征如下：

    1. 针对上层管理人员。
    2. 界面友好。
    3. 将模型、分析技术与传统的数据存取与检索技术结合起来。
    4. 对环境及决策方法改变的灵活性与适应性。
    5. 支持但不是代替决策。
    6. 利用先进信息技术快速传递和处理信息。

DSS系统的**管理者处于核心地位**，结合 DSS的支持进行决策。

DSS有两种级别结构形式：

1. 两库结构
2. 基于知识的结构

DSS支撑九项基本功能：

1. 多层决策，为决策整理和提供数据；
2. 收集、存储和提供外部信息；
3. 收集和提供活动的反馈信息；
4. 具有模型的存储和管理能力；
5. 对常用的各种方法的存储和管理；
6. 对各种数据、模型、方法进行管理；
7. 数据加工；
8. 具有人—机接口和图形加工；
9. 支持分布使用方式。

特点：

1. 面向决策者
2. 支持半结构化问题
3. 辅助支持
4. 过程动态
5. 交互

组建过程：

1. 数据重组
2. 建立数据仓库
3. 建立数据字典
4. 数据挖掘
5. 建立模型

**专家系统**

基于知识的专家系统（Expert System，ES）是一种**智能的计算机程序**，该程序使用**知识与推理过程**，求解那些需要资深专家的专门知识才能解决的高难度问题。

ES属于人工智能，**用于求解半结构化或非结构化问题**。

专家系统包括：

1. 机器人技术
2. 视觉系统
3. 自然语言处理
4. 学习系统
5. 神经网络等分支

专家系统与一般计算机系统的比较。

| 比较项    | 专家系统                           | 一般计算机系统       |
| ------ | ------------------------------ | ------------- |
| 功能     | 解决问题、解释结果、进行判断与决策              | 解决问题          |
| 处理能力   | 处理数字与符号                        | 处理数字          |
| 处理问题种类 | 多属准结构性或非结构性，可处理不确定的知识，使用于特定的领域 | 多属结构性，处理确定的知识 |

特点：

1. 超越时间限制
2. 操作成本低廉
3. 易于传递与复制
4. 处理手段一致
5. 善于克服难题
6. 适用特定领域等

组成：

1. 知识库
2. 综合数据库
3. 推理机
4. 知识获取
5. 解释程序人—机接口

**办公自动化系统**

办公自动化系统（Office Automatic System，OAS）可以解决包括数据、文字、声音、图像等信息的一体化处理问题，是一个集文字、数据、语言、图像为一体的综合性、跨学科的人机信息处理系统，可以**进行事务处理、信息管理和辅助决策**。

构成:

1. 计算机设备
2. 办公设备
3. 数据通信及网络设备
4. 软件系统

**企业资源规划**

企业资源规划（Enterprise Resource Planning，ERP）中的企业的

所有资源包括三大流：

1. **物流**
2. **资金流**
3. **信息流**

ERP是在信息技术基础上集成了企业的所有资源信息，为企业**提供决策、计划、控制与经营业绩评估**的全方位和系统化的管理平台。

ERP的管理范围涉及企业的所有供需过程，是对供应链的全面管理，还与人事系统和 CRM等关联。

ERP包括 11个基本模块：

1. 生产预测
2. 销售管理
3. 经营计划
4. 主生产计划
5. 物料需求计划
6. 能力需求计划
7. 车间作业计划
8. 采购与库存管理
9. 质量与设备管理
10. 财务管理。

ERP的功能有：

1. 支持决策
2. 不同行业的**针对性 IT解决方案**
3. 提供全行业和跨行业的**供应链**

#### 典型信息系统架构模型

**电子政务（Electronic Government，EG）**

电子政务是利用信息技术和其他相关技术，实现公务、政务、商务、事务的一体化管理与运行的政府形态改造的系统工程。

行为主体是：政府（Government）、企（事）业单位（Business）及居民（Citizen）。

| 名称         | 解释                                                                                                                        |
| ---------- | ------------------------------------------------------------------------------------------------------------------------- |
| 政府对政府（G2G） | 政府内部的政务活动，包括国家和地方基础信息的采集、处理和利用，如人口信息；政府之间各种业务流所需要采集和处理的信息，如计划管理；政府之间的通信系统，如网络系统；政府内部的各种管理信息系统，如财务管理；以及各级政府的决策支持系统和执行信息系统等 |
| 政府对企业（G2B） | 政府面向企业的活动主要包括政府向企（事）业单位发布的各种方针、政策、法规、行政规定，即企（事）业单位从事合法业务活动的环境，政府向企（事）业单位颁发的各种营业执照、许可证、合格证和质量认证等                           |
| 政府对居民（G2C） | 政府面向居民所提供的服务，以及各种关于社区公安和水、火、天灾等与公共安全有关的信息。户口、各种证件和牌照的管理等，还包括各公共部门，如学校、医院、图书馆和公园等                                          |
| 企业对政府（B2G） | 企业面向政府的活动包括企业应向政府缴纳的各种税款，按政府要求应该填报的各种统计信息和报表，参加政府各项工程的竞、投标，向政府供应各种商品和服务，以及申请的援助                                           |
| 居民对政府（C2G） | 包括个人应向政府缴纳的各种税款和费用，按政府要求应该填报的各种信息和表格，以及缴纳各种罚款等。此外，报警服务（盗贼、医疗、急救、火警等）即在紧急情况下居民需要向政府报告并要求政府提供的服务，也属于这个范围                    |

**企业信息化（Enterprise Informatization，EI）**

企业信息化是企业利用现代信息技术，实现经营活动的自动化、便捷化、网络化和智能化，以加强企业核心竞争力的过程。

企业信息化是技术和业务的融合，从**企业战略**、**业务运作**和**管理运作** 3个层面去实现。

企业信息化的方法有：

1. 业务流程重构方法
2. 核心业务应用方法
3. 信息系统建设方法
4. 主题数据库方法
5. 资源管理方法
6. 人力资本投资方法

**电子商务（Electronic Commerce，EC）**

电子商务指利用 Web提供的通信手段在网上买卖产品或提供服务，及其衍生行为。主要模式有：B2B、B2C、C2C、O2O（线上购买线下的服务）。

### 信息安全技术基础知识

#### 信息安全基础知识

**信息安全（Information Security）。**

信息安全是指为数据处理系统而采取的技术的和管理的安全保护，保护计算机硬件、软件、数据不因偶然的或恶意的原因而遭到破坏、更改和泄露。

基本要素有：

1. 机密性
2. 完整性
3. 可用性
4. 可控性
5. 可审查性

信息安全的范围：

1. 设备安全
2. 数据安全（确保数据免受未授权的泄露、篡改和毁坏）
3. 内容安全
4. 行为安全

信息存储安全的范围：信息使用的安全、系统安全监控、计算机病毒防治、数据的加密和防止非法的攻击等。

**网络安全**

网络安全漏洞和隐患表现：

1. 物理安全性
2. 软件安全漏洞
3. 不兼容使用安全漏洞

网络安全威胁表现：

1. 非授权访问
2. 信息泄露或丢失
3. 破坏数据完整性
4. 拒绝服务攻击
5. 利用网络传播病毒

安全措施的目标5个方面：

1. 访问控制
2. 认证
3. 完整性
4. 审计
5. 保密

#### 信息安全系统的组成框架

信息安全系统框架通常由**技术体系**、**组织机构体系**和**管理体系**共同构建。

从技术体系看，信息安全系统涉及

1. 基础安全设备
2. 计算机网络安全
3. 操作系统安全
4. 数据库安全
5. 终端设备安全

组织机构分为3个层次：

1. 决策层
2. 管理层
3. 执行层

管理体系3个部分组成：

1. 法律管理
2. 制度管理
3. 培训管理

#### 信息加解密技术

**数据加密**

数据加密是防止未经授权的用户访问敏感信息的手段，保障系统的机密性要素。

**对称密钥加密算法**

对称密钥算法的**加密密钥和解密密钥相同**，又称为共享密钥算法。

对称加密算法主要有：

1.  使用密钥加密的块算法（Data Encryption Standard，DES）

    明文切分为 **64位的块**（即分组），由 **56位的密钥**控制变换成 **64位的密文**。
2.  三重 DES（Triple-DES）

    DES的改进算法，使用两把 56位的密钥对明文做**三次 DES加解密**，**密钥长度为 112位**。
3. 国际数据加密算法（International Data Encryption Algorithm，IDEA）分组长度 **64位**，**密钥长度 128位**，全球通用的加密标准。
4.  高级加密标准（Advanced Encryption Standard，AES）

    **分组长度 128位**，支持 128位、192位和 256位 3种密钥长度，用于替换脆弱的 DES算法，且可以通过软件或硬件实现高速加解密。
5.  SM4国密算法

    分组长度和密钥长度都是 128位。

**非对称密钥加密算法**

非对称密钥加密算法的加密密钥和解密密钥不相同，又称为不共享密钥算法或公钥加密算法。

在非对称加密算法中用**公钥加密，私钥解密**，可实现**保密通信**

用**私钥加密，公钥解密**，可实现数字签名

非对称加密算法可以分为：

1.  RSA（Rivest，Shamir and Adleman）

    国际通用的公钥加密算法，安全性基于**大素数分解**的困难性，密钥的长度可以选择，但目前安全的**密钥长度已经高达 2048位**。RSA的计算速度比同样安全级别的对称加密算法**慢 1000倍**左右。
2.  SM2国密算法

    基于**椭圆曲线离散对数**问题，在相同安全程度的要求下，密钥长度和计算规模都比 RSA小得多。

#### 密钥管理技术

**密钥的使用控制**

控制密钥的安全性主要有**密钥标签**和**控制矢量**两种技术。

密钥的分配发送有：

1. 物理方式
2. 加密方式
3. 第三方加密方式

该第三方即密钥分配中心（Key Distribution Center， KDC）。

**公钥加密体制的密钥管理**

有4种方式：

1. 直接公开发布（如 PGP）
2. 公用目录表
3. 公钥管理机构
4. 公钥证书

公钥证书可以由个人下载后保存和传递

证书管理机构为 CA（Certificate Authority）

#### 访问控制及数字签名技术

**基本模型**

访问控制技术包括 3个要素，

1. 主体
2. 客体
3. 控制策略

访问控制包括3方面的内容：

1. 认证
2. 控制策略实现
3. 审计 （目的是防止滥用权力）

**访问控制的实现技术**

1.  访问控制矩阵（Access Control Matrix，ACM）

    以主体为行索引，以客体为列索引的矩阵，该技术是后面三个技术的基础，当主客体元素很多的时候实现困难。
2.  访问控制表（Access Control Lists，ACL）

    按列（即客体）保存访问矩阵，是目前最流行、使用最多的访问控制实现技术。
3.  表（Capabilities）

    按行（即主体）保存访问矩阵。
4.  授权关系表（Authorization Relations）

    抽取访问矩阵中的非空元素保存，当矩阵是稀疏矩阵的时候很有效，常用于安全数据库系统。

**数字签名**

数字签名是公钥加密技术与数字摘要技术的应用。

数字签名的条件是：

1. 可信
2. 不可伪造
3. 不可重用
4. 不可改变
5. 不可抵赖

基于对称密钥的签名只能在两方间实现，而且需要双方共同信赖的仲裁人。

利用公钥加密算法的数字签名则可以在任意多方间实现，不需要仲裁且可重复多次验证。

实际应用时先对文件做摘要，再对摘要签名，这样可以大大提升数字签名的速度。同时摘要的泄露不影响文件保密。

#### 信息安全的抗攻击技术

**密钥的选择**

密钥在概念上被分成两大类:

1. 数据加密密钥（DK）
2. 密钥加密密钥（KK）

**拒绝服务（Denial of Service, DoS）**

攻击DoS是**使系统不可访问并因此拒绝合法的用户服务要求的行为**，侵犯系统的可用性要素。

传统攻击的 4种模式：

1. 消耗资源
2. 破坏或更改配置信息
3. 物理破坏或改变网络部件
4. 利用服务程序中的处理错误使服务失效

目前常见的 DoS攻击模式：**分布式拒绝服务攻击**（Distributed Denial of Service，DDoS）

现有的 DDoS工具一般采用三级结构：

1. Client（客户端）
2. Handler（主控端）
3. Agent（代理端）

DoS防御的4种方法：

1. 特征识别
2. 防火墙
3. 通信数据量的统计
4. 修正问题和漏洞

**欺骗攻击与防御**

欺骗攻击与防御具体分为：

1.  ARP欺骗：

    ARP协议解析 IP地址为 MAC网卡物理地址，欺骗该机制即可阻断正常的网络访问。

    常用防范办法为:

    1. 固化 ARP表
    2. 使用 ARP服务器
    3. 双向绑定
    4. 安装防护软件
2.  DNS欺骗

    DNS协议解析域名为 IP地址，欺骗该机制可以使用户访问错误的服务器地址。

    3种方法检测：

    1. 被动监听检测
    2. 虚假报文探测
    3. 交叉检查查询
3.  IP欺骗

    攻击者修改 IP数据报的报头，把自身的 IP地址修改为另一个 IP，以获取信任。

    常用**防火墙等防范 IP欺骗**。

**端口扫描（Port Scanning）**

端口扫描是入侵者**搜集信息**的几种常用手法之一。

端口扫描尝试与目标主机的某些端口建立连接，如果目标主机该端口有回复，则说明该端口开放，甚至可以获取一些信息。

端口扫描分类：

1. 全TCP连接
2. 半打开式扫描（SYN扫描）
3. FIN扫描
4. 第三方扫描

**针对 TCP/IP堆栈的攻击方式**

**同步包风暴（SYN Flooding）**

应用最广泛的一种 DoS攻击方式，**攻击 TCP协议建立连接的三次握手，让目标主机等待连接完成而耗尽资源。**可以减少等待超时时间来防范。

**ICMP攻击**

例如“Ping of Death”**攻击操作系统的网络层缓冲区**，旧版操作系统会崩溃死机。防范方法是打补丁、升级到新版操作系统。

**SNMP攻击**

SNMP协议常用于管理网络设备，早期的 SNMP V1协议缺少认证，可能被攻击者入侵。防范方法是升级 SNMP协议到 V2以上并设置访问密码。

**系统漏洞扫描**

系统漏洞扫描指对重要计算机信息系统进行检查，发现其中可能被黑客利用的漏洞。漏洞扫描既是攻击者的准备工作，也是防御者安全方案的重要组成部分。

系统漏洞扫描分为：

1. 基于网络的漏洞扫描，通过网络来扫描目标主机的漏洞，常常被主机边界的防护所封堵，因而获取到的信息比较有限。
2. 基于主机的漏洞扫描，通常在目标系统上安装了一个代理（Agent）或者是服务（Services），因而能扫描到更多的漏洞。有扫描的漏洞数量多、集中化管理、网络流量负载小等优点。

#### 信息安全的保障体系与评估方法

**等级保护**

《计算机信息系统 安全保护等级划分准则》（GB 17859—1999）规定了计算机系统安全保护能力的 5个等级。

1. 第 1级：用户自主保护级（对应 TCSEC的 C1级）。
2. 第 2级；系统审计保护级（对应 TCSEC的 C2级）。
3. 第 3级；安全标记保护级（对应 TCSEC的 B1级）。
4. 第 4级：结构化保护级（对应 TCSEC的 B2级）。
5. 第 5级：访问验证保护级（对应 TCSEC的 B3级）

**安全保密技术**

安全保密技术主要有：

1.  数据泄密（泄露）防护（Data Leakage Prevention，DLP）。

    DLP是通过一定的技术手段，防止企业的**指定数据或信息资产以违反安全策略规定的形式流出企业**的一种策略。
2.  数字水印（Digital Watermark）。

    数字水印是指通过**数字信号处理方法，在数字化的媒体文件中嵌入特定的标记**。水印分为可感知的和不易感知的两种。

**安全协议**

常用的安全协议有：

* **SSL协议**。SSL协议是介于应用层和 TCP层之间的安全通信协议，
  * 保密性通信
  * 点对点身份认证
  * 可靠性通信
* **PGP（Pretty Good Privacy）**。PGP是一种加密软件，应用了多种密码技术，包括 RSA、IDEA、完整性检测和数字签名算法，实现了一个比较完善的密码系统。广泛地**用于电子邮件安全**。
* **互联网安全协议（Internet Protocol Security，IPSec）**。IPSec是工作在网络层的安全协议，主要优点是它的**透明性**，提供安全服务不需要更改应用程序。
* **SET协议**。主要用于解决用户、商家和银行之间**通过信用卡支付的交易问题**，保证支付信息的机密、支付过程的完整、商户和持卡人身份合法性及可操作性。
* **HTTPS协议**。

**信息系统的安全风险与评估**

信息系统的安全风险是指由于**系统存在的脆弱性所导致的安全事件发生的概率和可能造成的影响**。

风险评估是对**信息系统**及由其**处理、传输和存储的信息的保密性、完整性和可用性等**安全属性进行科学评价的过程，是信息安全保障体系建立过程中重要的**评价方法和决策机制**。

风险评估的基本要素为**脆弱性、资产、威胁、风险和安全措施**。

威胁是一种对机构及其资产**构成潜在破坏的可能性因素或者事件**。

脆弱性评估是安全风险评估中的重要内容，脆弱性不仅包括各种资产本身存在的脆弱性，没有正确实施的安全保护措施本身也可能是一个安全薄弱环节。

风险计算模型包含信息资产、弱点/脆弱性、威胁等关键要素。

### 系统工程基础知识

#### 系统工程

**定义与特点**

系统工程是运用系统方法，对系统进行规划、研究、设计、制造、试验和使用的组织管理技术，是人们用科学方法**解决复杂问题的一门技术**。

系统工程方法的特点：

1. 整体性
2. 综合性
3. 协调性
4. 科学性
5. 实践性

系统工程方法可以分为：

**霍尔的三维结构**

**时间维**

7个时间阶段：

1. 规划阶段。即调研、程序设计阶段，目的在于谋求活动的规划与战略。
2. 拟订方案。提出具体的计划方案。
3. 研制阶段。作出研制方案及生产计划。
4. 生产阶段。生产出系统的零部件及整个系统，并提出安装计划。
5. 安装阶段。将系统安装完毕，并完成系统的运行计划。
6. 运行阶段。系统按照预期的用途开展服务。
7. 更新阶段。即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。

**逻辑维**

7个逻辑步骤：

1. 问题
2. 确定目标
3. 系统综合
4. 系统分析
5. 优化
6. 决策
7. 实施

**知识维**

知识和技能:

* 工程
* 医学
* 建筑
* 商业
* 法律
* 管理
* 社会科学
* 艺术等

**切克兰德方法**

核心：不是“最优化”而是“比较”与“探寻”。

将工作过程分为7个步骤：

1. 认识问题
2. 根底定义
3. 建立概念模型
4. 比较及探寻
5. 选择
6. 设计与实施
7. 评估与反馈

**并行工程**

对产品及其相关过程（包括制造过程和支持过程）**进行并行、集成化处理的系统方法和综合技术。**

目标：提高质量、降低成本、缩短产品开发周期和产品上市时间。

**综合集成法**

从系统的本质出发可以把系统分为两大类：

1. 简单系统
2.  巨系统

    原则：

    1. 整体论
    2. 相互联系
    3. 有序性
    4. 动态

    性质：

    1. 开放性
    2. 复杂性
    3. 进化与涌现性
    4. 层次性
    5. 巨量性

**WSR系统方法**

物理—事理—人理方法论的简称。

具有中国传统哲学的思辨思想，是多种方法的综合统一，属于**定性与定量分析综合集成的东方系统思想**。

一般工作过程可理解为7步：

1. 理解意图
2. 制定目标
3. 调查分析
4. 构造策略
5. 选择方案
6. 协调关系
7. 实现构想

**系统工程的生命周期**

的生命周期阶段：

1. 探索研究
2. 概念阶段
3. 开发阶段
4. 生产阶段
5. 使用阶段
6. 保障阶段
7. 退役阶段

生命周期方法：

1. 计划驱动方法
2. 渐进迭代式开发
3. 精益开发
4. 敏捷开发

**基于模型的系统工程（Model-Based Systems Engineering，MBSE）**

MBSE是建模方法的形式化应用，以使建模方法支持系统需求、分析、设计、验证和确认等活动，持续贯穿到所有生命周期阶段。

产物包括：

1. 需求分析阶段，产生**需求图、用例图及包图**；
2. 功能分析与分配阶段，产生**顺序图、活动图及状态机图**；
3. 在设计综合阶段，产生**模块定义图、内部块图及参数图**等。

系统工程的三大支柱：

1. 建模语言
2. 建模工具
3. 建模思路

**系统性能**

**1．系统性能评价**

系统性能评价指标是**软件、硬件的性能指标的集成**。

计算机的主要性能指标：

1. 时钟频率（主频）
2. 运算速度
3. 运算精度
4. 数据处理速率（Processing Data Rate，PDR）
5. 吞吐率

路由器的主要性能指标：

1. 设备吞吐量
2. 端口吞吐量
3. 全双工线速转发能力
4. 路由表能力
5. 背板能力
6. 丢包率
7. 时延
8. 时延抖动
9. 协议支持。

交换机性能指标：

1. 端口速率
2. 背板吞吐量
3. 缓冲区大小
4. MAC地址表大小

网络的性能指标：

1. 设备级性能指标
2. 网络级性能指标
3. 应用级性能指标
4. 用户级性能指标
5. 吞吐量

操作系统的性能指标：

1. 系统上下文切换系统响应时间
2. 系统的吞吐率（量）
3. 系统资源利用率
4. 可靠性
5. 可移植性

数据库管理系统的主要性能指标：

1. 最大并发事务处理能力
2. 负载均衡能力
3. 最大连接数等。

评价 Web服务器的主要性能指标：

1. 最大并发连接数
2. 响应延迟
3. 吞吐量。

**2．性能指标计算**

主要方法：

1. 定义法
2. 公式法
3. 程序检测法
4. 仪器检测法

计算公式主要有：

1. 每秒百万次指令数（Millions of Instructions Per Second，MIPS）MIPS=指令条数/(执行时间×106)
2. 峰值计算，是指计算机每秒钟能完成的浮点计算最大次数。
   1. 包括理论浮点峰值（理论浮点峰值= CPU主频×CPU每个时钟周期执行浮点运算的次数×系统中 CPU数 ）
   2. 实测浮点峰值
3.  等效指令速度法或吉普森（Gibson）法，早期用加法指令的运算速度来衡量计算机的速度，后来发展为各个指令的运算时间乘以占比。

    通常加、减法指令占 50%，乘法指令占 15%，除法指令占 5%，程序控制指令占 15%，其他指令占 15%。

**3．性能调整**

性能调整由查找和消除瓶颈组成。

对于数据库系统，性能调整主要包括：

1. CPU/内存使用状况
2. 优化数据库设计
3. 优化数据库管理以及进程/线程状态
4. 硬盘 I/O及剩余空间
5. 日志文件大小等

对于应用系统，性能调整主要包括：

1. 应用系统的可用性
2. 响应时间
3. 并发用户数
4. 特定应用的系统资源占用

**4．阿姆达尔（Amdahl）解决方案**

阿姆达尔定律：计算机系统中**对某一部件采用某种更快的执行方式所获得的系统性能改变程度，取决于这种方式所占总执行时间的比例**。

加速比的定义：

加速比=使用增强部件时完成整个任务的时间/不使用增强部件时完成整个任务的时间

新的执行时间=原来的执行时间×\[(1-增强比例)+增强比例/增强加速比]

总加速比=原来的执行时间/新的执行时间=1/\[(1-增强比例)+增强比例/增强加速比]

加速比主要取决于两个因素：

* 在原有的计算机上，能被改进并增强的部分在总执行时间中所占的比例，这个值称为增强比例，它永远小于等于 1；
* 通过增强的执行方式所取得的改进，即如果整个程序使用了增强的执行方式，那么这个任务的执行速度会有多少提高，这个值是在原来条件下程序的执行时间与使用增强功能后程序的执行时间之比。

**性能评估**

性能评估主要包括：

基准测试程序（Benchmark）定义：应用程序中用得最多、最频繁的那部分核心程序。

基准测试程序中，评测的准确程度依次递减：真实的程序、核心程序、小型基准程序和合成基准程序。

基准测试程序有:

1. 整数测试程序 Dhrystone
2. 浮点测试程序 Linpack
3. Whetstone基准测试程序
4. SPEC基准测试程序和
5. TPC基准程序

Web服务器的性能评测方法有：

1. 基准性能测试
2. 压力测试
3. 可靠性测试

系统监视的方法通常有3种方式：

1. 系统内置命令
2. 查阅系统日志
3. 可视化技术

### 软件工程基础知识

#### 软件工程

**软件危机（Software Crisis）**

具体表现为：

1. 软件开发**进度**难以预测
2. 软件开发**成本**难以控制
3. 软件**功能**难以满足用户期望
4. 软件**质量**无法保证
5. 软件难以**维护**
6. 软件缺少适当的**文档资料**

**软件过程模型**

软件的生命周期：

1. 需求分析
2. 软件设计
3. 软件开发
4. 运行维护
5. 淘汰

为了使软件生命周期中的各项任务能够有序地按照规程进行**，需要一定的**工作模型对各项任务给予规程约束，这样的工作模型被称为**软件过程模型**，有时也称为软件**生命周期模型**。

**瀑布模型（Waterfall Model）**

特点：**因果关系紧密相连，前一个阶段工作的输出结果，是后一个阶段工作的输入**。

每一个阶段工作完成后都伴随着一个里程碑。

缺点：

1. 需求难以一次确定
2. 变更的代价高
3. 结果难以预见
4. 各阶段工作不能并行

**原型模型（Prototype Model）**

原型模型**解决了瀑布模型需求难以一次确定、结果难以预见的缺点**。

原型模型两个阶段：

1. 原型开发
2. 目标软件开发

抛弃型原型将原型作为**需求确认的手段**，在需求确认结束后就被抛弃不用，继续用瀑布模型。

演化性原型在需求确认结束后，**不断补充和完善原型**，直至形成一个完整的产品。

**螺旋模型（Spiral Model）**

在快速原型的基础上结合瀑布模型扩展而成。

把整个软件开发流程分成多个阶段，

每一个阶段都由 4部分组成：

1. 目标设定
2. 风险分析
3. 开发和有效性验证
4. 评审。

支持大型软件开发，适用于面向规格说明、面向过程和面向对象的软件开发方法，强调其他模型忽视的**风险分析**。

**4）敏捷（Agile）模型**

敏捷模型主要方法：

1. 极限编程（XP）：高效、低风险、测试先行（先写测试代码，再编写程序）。
2. 水晶系列方法：不同的项目，采用不同的策略。
3.  并列争球法（Scrum）：该方法侧重于项目管理。

    Scrum包括一系列实践和预定义角色的过程骨架（是一种流程、计划、模式，用于有效率地开发软件）。

    在 Scrum中，使用产品 Backlog来管理产品的需求，产品 Backlog是一个按照商业价值排序的需求列表。

    根据 Backlog的内容，将整个开发过程分为若干个短的迭代周期（Sprint），在 Sprint中，Scrum团队从产品Backlog中挑选最高优先级的需求组成 Sprint Backlog。在每个迭代结束时，Scrum团队将递交潜在可交付的产品增量。

    当所有 Sprint结束时，团队提交最终的软件产品。
4. 特征驱动开发方法：该方法会将开发人员分类，分为指挥者（首席程序员）、类程序员等。

**软件统一过程（Rational Unified Process，RUP）模型。**

RUP是一种重量级过程模型，属于构件化开发使用的软件过程模型。

其生命周期是一个二维的软件开发模型，划分为多个循环（Cycle），每个循环生成产品的一个新的版本，每个循环依次由**初始、细化、构造和移交** 4个连续的阶段（Phase）组成，每个阶段完成确定的任务。

RUP中 9个核心工作流：

1. 业务建模
2. 需求
3. 分析与设计
4. 实现
5. 测试
6. 部署
7. 配置与变更管理
8. 项目管理
9. 环境。

RUP的特点是**用例驱动的、以架构为中心的、迭代和增量**的软件开发过程。

RUP用“4+1”视图模型来描述架构：

*   逻辑视图

    对应**最终用户**，主要**支持功能性需求**，即在为用户提供服务方面系统所应该提供的功能。逻辑视图常用**类图、对象图、状态图、协作图**表示。
*   实现视图

    又称为开发视图，对应**程序员**，关注软件开发环境下实际模块的组织，描述系统的各部分如何被组织为模块和组件即**开发环境中软件的静态组织结构**。该视图通常包含**包图和组件图**。
*   进程视图

    又叫过程视图，对应**系统集成人员**，考虑一些**非功能性的需求**，如性能和可用性，它可以解决并发性、分布性、系统完整性、容错性的问题。进程视图常用**活动图表示**。
*   部署视图

    又叫物理视图，对**应系统工程师**。描述如何将前三个视图中所述的系统设计实现为一组现实世界的实体。展示了如何把软件映射到硬件上，它通常要考虑到系统性能、规模、可靠性等。**解决系统拓扑结构、系统安装、通信等问题**。部署视图常用**部署图表示**。
*   用例视图

    **所有其他视图都依靠用例视图（场景）来指导它们**，这就是将模型称为“4+1”的原因。

RUP在每次迭代中，只考虑系统的一部分需求，进行分析、设计、实现、测试和部署等过程。

**软件能力成熟度模型（Capability Maturity Model for Software，CMM）**

CMM是一个概念模型，模型框架和表示是刚性的，不能随意改变，但模型的解释和实现有一定弹性。

**软件能力成熟度模型集成（Capability Maturity Model Integration for Software，CMMI）**

CMMI是在 CMM的基础上发展而来的。

软件过程改进的步骤组织成 5个成熟度等级：

1. 初始级
2. 已管理级
3. 已定义级
4. 量化管理级
5. 优化级

量化管理级与已定义级的区别是对过程性能的可预测。

#### 需求工程

**软件需求的层次**

软件需求包括 3个不同的层次。

1. 业务需求（Business Requirement），反映了**组织机构或客户**对系统、产品**高层次的目标**要求。
2. 用户需求（User Requirement），描述了用户使用产品必须要完成的任务，是**用户对该软件产品的期望**。业务需求和用户需求构成了用户原始需求文档的内容。
3. 功能需求（functional requirement），从**系统操作的角度**定义了开发人员必须实现的软件功能，来满足业务需求和用户需求。

**需求工程（Requirement Engineering，RE）**

需求工程是指应用已证实有效的原理、方法，通过合适的工具和记号，**系统地描述待开发系统及其行为特征和相关约束**。

需求工程由5个阶段组成：

1. 需求获取
2. 需求分析
3. 形成需求规格（或称为需求文档化）
4. 需求确认与验证
5. 需求管理

**软件需求规格说明书（Software Requirement Specification，SRS）**

SRS具体包括**功能需求、非功能**需求和约束。

约束包括**设计约束**和**过程约束**。

批准的 SRS是需求开发和需求管理之间的桥梁。

**需求管理**

需求管理是一个对系统**需求变更、了解和控制的过程**，包括**变更控制、版本控制、需求跟踪**等活动。

**需求获取**

需求获取是获得系统必要的特征，或者是获得用户能接受的、系统必须满足的约束。

需求获取的基本步骤：

1. 开发高层的业务模型。
2. 定义项目范围和高层需求。
3. 识别用户角色和用户代表。
4. 获取具体的需求。
5. 确定目标系统的业务工作流。
6. 需求整理与总结

需求获取的方法：

1. 用户面谈
2. 需求专题讨论会
3. 问卷调查
4. 现场观察
5. 原型化方法
6. 头脑风暴法

**需求变更**

需求变更管理过程如图 7.6所示。图 7.6 需求变更管理过程

**7．变更控制委员会（Change Control Board，CCB）**

CCB由项目所涉及的多方成员共同组成，通常包括**用户和实施方的决策人员**。

CCB是决策机构，不是作业机构，通常 CCB的工作是通过评审手段来决定项目是否能变更，但不提出变更方案。

过程及操作步骤为：

1. 制定决策
2. 交流情况
3. 重新协商约定

**8．需求跟踪**

需求跟踪提供了由需求到产品实现整个过程范围的明确查阅的能力。

需求跟踪的目的是建立与维护“需求—设计—编程—测试”之间的一致性，确保所有的工作成果符合用户需求。

需求跟踪有正向跟踪和逆向跟踪两种方式，合称为“双向跟踪”。

不论采用何种跟踪方式，都要建立与维护需求跟踪矩阵。

#### 系统分析与设计

**结构化方法（Structured Analysis and Structured Design，SASD）**

结构化方法又称为**面向功能**的软件开发方法或**面向数据流**的软件开发方法。

针对软件生存周期各个不同的阶段，有结构化分析、结构化设计和结构化编程等方法。

**结构化分析（Structured Analysis，SA）**

SA利用图形表达用户需求中的功能需求。

使用的手段主要有：

1. 数据流图（Data Flow Diagram，DFD）
2. 数据字典
3. 结构化语言
4. 判定表以及判定树

数据流图（DFD）由 4种基本元素组成：

1. 数据流
2. 处理/加工
3. 数据存储
4. 外部项

结构化分析具体的建模过程及步骤为

1. 明确目标
2. 确定系统范围
3. 建立顶层 DFD图
4. 构建第一层 DFD分解图
5. 开发 DFD层次结构图
6. 检查确认 DFD图

DFD图需要满足规则：

1. 父图数据流必须在子图中出现；一个处理至少有一个输入流和一个输出流；
2. 一个存储必定有流入和流出；一个数据流至少有一端是处理端；
3. 模型表达的信息是全面的、完整的、正确的和一致的。

数据字典（Data Dictionary）是一种标记用户可以访问的数据项和元数据的目录，是对系统中使用的所有数据元素定义的集合，包括数据项、数据结构、数据流、数据存储和处理过程。

**结构化设计（Structured Design，SD）。**

SD是一种面向数据流的设计方法，以 SRS和 SA阶段所产生的数据流图和数据字典等文档为基础，是一个**自顶向下、逐步求精和模块化的过程**。

SD分两个阶段：

1. 概要设计。
   1. 确定软件**系统的结构**
   2. 对系统进行**模块划分**
   3. 确定每个模块的**功能**
   4. 确定接口和**模块之间的调用**关系
2.  详细设计

    为每个模块设计实现的细节

模块是实现功能的基本单位，一般具有**功能、逻辑和状态** 3个基本属性。

耦合表示模块之间联系的程度，耦合度从低到高依次如表 7.1所示。

| 耦合类型  | 描述                                                                  |
| ----- | ------------------------------------------------------------------- |
| 非直接耦合 | 两个模块之间没有直接关系，互相不依赖对方                                                |
| 数据耦合  | 一组模块借助参数表传递简单数据                                                     |
| 标记耦合  | 一组模块通过参数表传递记录等复杂信息（数据结构）                                            |
| 控制耦合  | 模块之间传递的信息中包含用于直接控制模块内部逻辑的信息                                         |
| 通信耦合  | 一组模块共享了输入或输出                                                        |
| 公共耦合  | 多个模块都访问同一个公共数据环境，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等                  |
| 内容耦合  | 一个模块直接访问另一个模块的内部数据、一个模块不通过正常入口跳转到另一个模块的内部、两个模块有一部分程序代码重叠、一个模块有多个入口等 |

模块的内聚类型

| 内聚类型 | 描述                                |
| ---- | --------------------------------- |
| 功能内聚 | 各个部分协同完成一个单一功能，缺一不可               |
| 顺序内聚 | 处理元素相关，而且必须顺序执行，通常前一任务的输出是后一任务的输入 |
| 通信内聚 | 所有处理元素集中在一个数据结构的区域上               |
| 过程内聚 | 处理元素相关，而且必须按特定的次序执行               |
| 时间内聚 | 所包含的任务必须在同一时间间隔内执行                |
| 逻辑内聚 | 完成逻辑上相关的一组任务，互相存在调用关系             |
| 偶然内聚 | 完成一组没有关系或松散关系的任务，或者仅仅代码相似         |

模块分解中应遵循“高内聚、低耦合”的设计原则。

概要设计使用系统结构图（Structure Chart，SC），又称为模块结构图，反映了系统的总体结构。

详细设计的主要任务是设计每个模块的实现算法、所需的局部数据结构。

详细设计的表示工具有图形工具、表格工具和语言工具。图形有业务流图、程序流程图、问题分析图（Problem Analysis Diagram，PAD）、NS流程图等。

**结构化编程（Structured Programming，SP）**

SP通过顺序、分支和循环三种基本的控制结构可以构造出任何单入口单出口的程序。

SP强调：

1. 自顶向下，逐步细化；
2. 清晰第一，效率第二；
3. 书写规范，缩进格式；
4. 基本结构，组合而成。

P原则：程序=(算法)+(数据结构)。两者分开设计，以算法（函数或过程）为主。

**数据库设计（概念结构设计部分）。**

概念结构设计建立抽象的概念数据模型，通常采用实体-联系图（Entity Relationship Diagram，E-R图）来表示。

**2．面向对象（Object-Oriented，OO）**

方法面向对象的方法可以分为：

**（1）面向对象的分析方法（Object-Oriented Analysis，OOA）**

OOA模型 5个层次：

1. 主题层
2. 对象类层
3. 结构层
4. 属性层
5. 服务层

5个活动：

1. 标识对象类
2. 标识结构
3. 定义主题
4. 定义属性
5. 定义服务

OOA的基本原则：

1. 抽象
2. 封装
3. 继承
4. 分类
5. 聚合
6. 关联
7. 消息通信
8. 粒度控制
9. 行为分析

OOA的 5个基本步骤：

1. 确定对象和类
2. 确定结构
3. 确定主题
4. 确定属性
5. 确定方法

**面向对象设计方法（Object-Oriented Design，OOD）**

在 OOD中，数据结构和在数据结构上定义的操作算法封装在一个对象之中。

类封装了信息和行为，是具有相同属性、方法和关系的对象集合的总称。

类可以分为 3种类型：

1. 实体类：一般来说是一个名词，通常都是永久性需要存储的，例如教师、学生。
2. 控制类：是用于控制用例工作的类，控制对象（控制类的实例）通常控制其他对象或协调其他对象的行为，例如登录验证。
3. 边界类：用于封装在用例内、外流动的信息或数据流，例如窗口、通信协议、接口等。

**面向对象程序设计（Object-Oriented Programming，OOP）**

OOP以对象为核心，该方法认为程序由一系列对象组成。

OOP的基本特点有：

1. 封装（将一个计算机系统中的数据以及与这个数据相关的一切操作组装到一起）。
2. 继承（一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续）。
3. 多态（同一操作作用于不同的对象，可以产生不同的结果）。

**数据持久化与数据库**

永久保存对象的状态，需要进行对象的持久化（Persistence），把内存中的对象保存到数据库或可永久保存的存储设备中。

在多层软件设计和开发中采用持久层（Persistence Layer）专注于实现数据持久化，将对象持久化到关系数据库中，需要进行对象/关系的映射（Object/Relation Mapping，ORM）。

目前主流的持久化技术框架包括 Hibernate、iBatis/Mybatis和 JDO等。

Hibernate：是一个开源的全自动的 ORM框架，对 JDBC进行了非常轻量级的对象封装，提供抽象的 HQL可以自动生成不同数据库的 SQL语句，优点是具有跨数据库平台的特性。

iBatis/Mybatis：提供手动的 ORM实现，需要程序员手写 SQL，优点是可以结合特定的数据库特性深度优化。

Java数据对象（Java Data Object，JDO）：是 Java标准中的持久化 API，提供了透明的对象存储，并且不仅仅支持关系数据库，还支持普通文件、XML文件和对象数据库等。

**其他设计方法**

其他设计方法如构件与软件重用。软件重用是使用已有软件产品来开发新的软件系统的过程，分为水平式重用和垂直式重用两种类型。

| 名称    | 对象           | 举例    |
| ----- | ------------ | ----- |
| 水平式重用 | 不同应用领域中的软件元素 | 标准函数库 |
| 垂直式重用 | 共性应用领域间的软部件  | 区块链   |

**逆向工程（Reverse Engineering）**

逆向工程是通过分析已有的程序，寻求比源代码更高级的抽象表现形式（比如文档）的活动，是在不同抽象层级中进行的溯源行为。

逆向工程得出的设计称为设计恢复（Design Recovery），但不一定能够抽象还原到原设计。

重构（Restructuring）是在同一抽象层级中转换系统描述的活动。对逆向工程所形成的系统进行修改或重构，生成的新版本称为重构工程。

| 级别  | 内容            |
| --- | ------------- |
| 实现级 | 语法树、符号表       |
| 结构级 | 程序分量间的关系，如调用图 |
| 功能级 | 功能和程序段之间的关系   |
| 领域级 | 实体与应用域之间的关系   |

软件测试

软件测试的目的测试是确保软件的质量，确认软件以正确的方式做了用户所期望的事情。

软件测试通常在规定的时间和成本内完成，以尽量多地发现漏洞，但不能保证发现所有的漏洞。

测试分类

程序执行状态：

1. 静态测试（Static Testing，ST）
2. 动态测试（Dynamic Testing，DT）

是否关注具体实现和内部结构：

1. 黑盒测试
2. 白盒测试和灰盒测试

程序执行的方式来：

1. 人工测试（Manual Testing，MT）
2. 自动化测试（Automatic Testing，AT）。

从阶段上划分：

1. 单元测试。对该软件的模块进行测试，往往由程序员自己完成。常采用白盒的静态测试如静态分析、代码审查等，也可以采用自动化的动态测试。
2. 集成测试。对通过单元测试的模块进行组装测试，以验证组装的正确性，一般采用白盒测试和黑盒测试结合的方法。
3. 系统测试。**检查组装完成的系统是否符合 SRS的要求**。主要测试内容包括功能测试、性能测试、健壮性测试、安全性测试等，结束标志是测试工作已满足测试目标所规定的需求覆盖率，并且测试所发现的缺陷都已全部归零。
4. 验收测试。**确认系统满足用户需求或者协议的要求**，确保系统能支撑业务运行

其他测试还有 AB测试、Web测试、链接测试和表单测试等。

#### 净室软件工程

净室软件工程（Cleanroom Software Engineering，CSE）是一种在软件开发过程中强调在软件中建立正确性的需要的方法。

CSE的理论基础主要是函数理论和抽样理论。

CSE使用盒子结构规约进行分析和设计建模，并且强调将正确性验证（而不是测试）作为发现和消除错误的主要机制，可以生成质量非常高的软件。

CSE的缺点是太理论化、忽视测试、带有传统软件工程的弊端。

#### 基于构件的软件工程

**定义**

基于构件的软件工程（Component-Based Software Engineering，CBSE）是一种基于分布对象技术、**强调通过可复用构件设计与构造软件系统的软件复用途径**。

用于 CBSE的构件应该具备以下特征：

1. 可组装型：所有外部交互必须通过公开定义的接口进行。
2. 可部署性：必须能作为一个独立实体在提供其构件模型实现的构件平台上运行。
3. 文档化：构件必须是完全文档化的。
4. 独立性：构件应该是独立的，如确实需要其他构件提供服务，则应显示声明。
5. 标准化：必须符合某种标准化的构件模型。

**构件模型**

构件模型定义了构件实现、文档化以及开发的标准。

目前主流的构件模型是 Web Services模型、Sun公司的 EJB模型和微软的.NET模型。

构件模型包含了一些模型要素如接口、使用信息和部署信息。

构件模型提供了一组被构件使用的通用服务，包括平台服务和支持服务。

容器是构件模型基础设施，是支持服务的一个实现加上一个接口定义，构件必须提供该接口定义以便和容器整合在一起。

**CBSE过程**

支持基于构件组装的软件开发过程主要包括：

1. 系统需求概览。
2. 识别候选构件。
3. 根据发现的构件修改需求。
4. 体系结构设计
5. 构件定制与适配。
6. 组装构件，创建系统。

CBSE过程与传统的软件开发过程的不同点：

1. 早期需要完整的需求，以便尽可能多地识别出可复用的构件。
2. 早期阶段根据可利用的构件来细化和修改需求以匹配 CBSE。
3. 架构设计完成后，可能需要修改构件以适合功能和架构的需求。
4. 开发过程就是组装构件的过程，有时需要开发适配器。
5. CBSE中的架构设计阶段特别重要，决定和限制了可选构件的范围。

**构件组装**

常见的构件组装有3种组装方式：

1. 顺序组装
2. 层次组装
3. 叠加组装

常见的有 3种。

1. 参数不兼容
2. 操作不兼容
3. 操作不完备

这时需要编写适配器构件来解决不兼容的问题。

#### 软件项目管理

**软件进度管理**

进度管理6个过程：

1. 活动定义
2. 活动排序
3. 活动资源估计
4. 活动历时估计
5. 制定进度计划
6. 进度控制

**工作分解结构（Work Breakdown Structure，WBS）**

把一个项目，按一定的原则分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的活动中，直到分解不下去为止。

以可交付成果为导向，对项目要素进行的分组，总是处于计划过程的中心。

**活动定义**

确定完成项目的各个可交付成果所必须进行的各项具体活动，还需要明确每个活动的前驱、持续时间、必须完成日期、里程碑或可交付成果。

**任务活动图**

项目进度管理、项目成本管理等一系列项目管理活动的基础，通常采用甘特图等方式来展示和管理项目活动。

**软件配置管理（Software Configuration Management，SCM）**

一种标识、组织和控制修改的技术。

SCM的目的是使错误降为最小并最有效地提高生产效率。SCM的核心内容包括版本控制和变更控制。版本控制（Version Control）是指对软件开发过程中各种文件变更的管理，最主要的功能就是追踪和记录文件的变更、并行开发。变更控制（Change Control）是指对变更进行管理，确保变更有序进行。

**软件质量管理**

软件质量就是软件与明确地和隐含地定义的需求相一致的程度。软件质量保证（Software Quality Assurance，SQA）的目的是使软件过程对于管理人员来说是可见的。

SQA的主要任务是：

1. SQA审计与评审，包括对软件工作产品、软件工具和设备的审计，评审开发组的行为符合预定的过程。
2. SQA报告。
3. 处理不符合问题。软件质量认证，国内软件企业主要采用的是 ISO 9001和 CMM。

**软件风险管理**

软件项目风险是指在软件开发过程中遇到的预算和进度等方面的问题以及这些问题对软件项目的影响。风险管理的主要目标是预防风险，及应对发生的风险。

风险管理活动可以分为：

Bochm把风险管理活动分成风险估计（风险辨识、风险分析、风险排序）和风险控制（风险管理计划、风险处理、风险监督）两大阶段。

Charette把风险分成分析（辨识、估计、评价）和管理（计划、控制、监督）两大阶段。

### 数据库设计基础知识

**数据库基础概念**

**基础概念**

数据（Data）：是描述事物的符号记录，它具有多种表现形式，如文字、图形、图像、声音和语言等。

数据库系统（DataBase System，DBS）：是一个采用了数据库技术，有组织地、动态地存储大量相关联数据，从而方便多用户访问的计算机系统。

数据库（DataBase，DB）：是统一管理的、长期储存在计算机内的，有组织的相关数据的集合。

数据库管理系统（DataBase Management System，DBMS）：是数据库系统的核心软件，是由一组相互关联的数据集合和一组用以访问这些数据的软件组成。

DBMS通常分三类：

1. 关系数据库系统（Relation DataBase System，RDBS）
2. 面向对象的数据库系统（Object-Oriented DataBase Systems，OODBS）
3. 对象关系数据库系统（Objective Relational DataBase System， ORDBS）

**发展阶段**

1.  人工管理阶段。

    特点：

    1. 数据量较少
    2. 数据不保存
    3. 没有软件系统对数据进行处理

    缺点：

    1. 应用程序与数据之间依赖性太强
    2. 数据组与数据组之间存在数据冗余。
2.  文件系统阶段

    特点：

    1. 数据可长期保留
    2. 数据不属于某个特定应用
    3. 文件组织形式多样化

    缺点：

    1. 数据冗余
    2. 数据不一致性
    3. 数据孤立
3.  数据库系统阶段

    特点：

    1. 采用复杂的数据模型表示数据结构
    2. 有较高的数据独立性

    优点：

    1. 对应用程序的高度独立性
    2. 数据的充分共享性
    3. 操作方便性

**数据模型**

数据模型三要素：

1. 数据结构
2. 数据操作
3. 数据的约束条件
   1. 实体完整性。实体的主属性不能取空值。
   2.  参照完整性。主要是指外键参照的完整性。

       若 A关系中的某个或者某些属性参照 B关系或其他几个关系中的属性，那么在关系 A中该属性要么为空，要么必须出现在 B关系或者其他的关系的对应属性中。
   3.  用户定义完整性。反映的是某一个具体应用所对应的数据必须满足一定的约束条件。

       例如，软考成绩不能小于 0，也不能大于 75。

**数据库管理系统**

数据库管理系统的**主要功能**包括：

1. 数据定义
2. 数据库操作
3. 数据库运行管理
4. 数据组织
5. 存储和管理
6. 数据库的建立和维护

数据库管理系统的**特点**：

1. 数据结构化且统一管理
2. 有较高的数据独立性
3. 数据控制功能。

数据控**制功能包括**：

1. 安全性
2. 完整性
3. 并发控制的能力

**数据库三级模式两级映像**

数据库一般采用三级模式，系统开发人员需要通过**视图层、逻辑层和物理层**三个层次上的抽象来降低用户屏蔽系统的复杂性，简化用户与系统的交互。

![image-20240513142608876](file:///C:/Users/chenkanglin/Nutstore/1/exem/assets/image-20240513142608876.png?lastModify=1715749652)

从数据库管理系统的角度，数据库也分为三级模式 ：

1. 概念模式 ：是数据库中**全体数据的逻辑结构和特征的描述\***\*，是所有用户的公共数据视图。
2. 外模式：又叫子模式或用户模式，用以**描述用户看到或使用的那部分数据的逻辑结构**，用户根据外模式**用数据操作语句或应用程序去操作数据库中的数据**。
3. 内模式：是**数据物理结构和存储方式的描述**，是数据在**数据库内部的表示方式**，定义所有的内部记录类型、索引和文件的组织方式等

系统在三级模式之间提供了两级映像：

1. 概念模式/内模式映像
2. 外模式/概念模式映像

这两级映像**保证了数据库中的数据具有较高的逻辑独立性和物理独立性**

| 逻辑独立性                                                    | 物理独立性                                                   |
| -------------------------------------------------------- | ------------------------------------------------------- |
| 对应外模式和概念模式之间的映像。**指应用程序与数据库中的逻辑结构独立**，当数据的逻辑结构改变时，应用程序不变 | 对应概念模式和内模式之间的映像。**指应用程序与磁盘中的数据互相独立。**当数据的物理存储改变时，应用程序不变 |

#### 关系数据库

**基本概念**

属性（Attribute）：在现实世界中，要**描述一个事物常常取若干特征来表示**。这些**特征**称为属性。

域（Domain）：每个**属性的取值范围对应一个值的集合**，称为该属性的域。

目或度（Degree）：目或度指的是一个关系中**属性的个数**。

候选码（Candidate Key）：若关系中的某一属性或属性组的值，**能唯一地标识一个元组**，则称该**属性或属性组为候选码**。

主码（Primary Key）：或称主键，若一个关系有**多个候选码**，则**选定其中一个**作为主码。

主属性（Prime Attribute）：包含在**任何候选码中的属性**称为主属性。

外码（Foreign Key）：如果关系模式 R中的属性或属性组不是该关系的码，**但它是其他关系的码**，那么该属性对关系模式 R而言是外码。

全码（All-key）：关系模型的**所有属性组是这个关系模式的候选码**，称为全码。

关系代数运算

关系代数的运算符有 4类：

1. 集合运算符
2. 专门的关系运算符
3. 算术比较符
4. 逻辑运算符

集合 运算符

* ∪ 并 关系 R与 S的并是由属于 R或属于 S的元组构成的集合
* － 差 关系 R与 S的差是由属于 R但不属于 S的元组构成的集合
* ∩ 交 关系 R与 S的交是由属于 R同时又属于 S的元组构成的集合
* × 笛卡儿积 两个关系分别为 n列和 m列的关系 R和 S的笛卡儿积是一个（n+m）列的元组的集合。其中的前 n列是关系 R的一个元组，后 m列是关系 S的一个元组，记作 R×S，如果 R和 S有相同的属性名，可在属性名前加关系名作为限定，以示区别。若 R有K1个元组，S有 K2个元组，则 R和 S的笛卡儿积有 K1×K2个元组

专门的关系运算符

* σ 选择 取得关系 R中符合条件的行
* π 投影 取得关系 R中符合条件的列
*  连接
  1. 等值连接：选取关系 R、S，取两者笛卡儿积中属性值相等的元组。
  2. 自然连接：一种特殊的等值连接，它要求比较的属性列必须是相同的属性组，并且把结果中重复属性去掉。
*   ÷ 除 给定关系 R(X，Y)和 S(Y，Z)，其中 X，Y，Z为属性组。

    R中的 Y与 S中的 Y可以有不同的属性名，但必须出自相同的域集。R与 S的除运算得到一个新的关系P(X)，P是 R中满足下列条件的元组在 X属性列上的投影：元组在 X上分量值 x的象集 Yx包含 S在 Y上投影的集合

| 运算符                                                                                                                                                              | 含义    | 名词解释                                                                                     |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- | ---------------------------------------------------------------------------------------- |
| <img src="file:///C:/Users/chenkanglin/AppData/Roaming/Typora/typora-user-images/image-20240513134456464.png?lastModify=1715749652" alt="" data-size="original"> | 左外连接  | 取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值 null填充所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中                     |
| <img src="file:///C:/Users/chenkanglin/AppData/Roaming/Typora/typora-user-images/image-20240513134502851.png?lastModify=1715749652" alt="" data-size="original"> | 右外连接  | 取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值 null填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中                     |
| <img src="file:///C:/Users/chenkanglin/AppData/Roaming/Typora/typora-user-images/image-20240513134510544.png?lastModify=1715749652" alt="" data-size="original"> | 完全外连接 | 完成左外连接和右外连接的操作。即填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生的新元组加入自然连接的结果中 |

**关系数据库设计基本理论**

**函数依赖**

设 R(U)是属性 U上的一个关系模式，X和 Y是 U的子集，r是 R的任一关系，如果对于 r中的任意两个元组 u和 v，只要有 u\[X]=v\[X]，就有 u\[Y]=v\[Y]，则称 X函数决定 Y，或称 Y函数依赖于 X，记为 X→Y。

函数依赖是一种最重要、最基本的数据依赖。而关系数据库设计理论的核心就是数据间的函数依赖。

**非平凡的函数依赖**

如果 X→Y，Y⊆X，则称 X→Y是非平凡的函数依赖。

**平凡的函数依赖**

如果 X→Y，但 Y⊆X，则称 X→Y是平凡的函数依赖。

**完全函数依赖**

例如，有学生关系模式（学号，系号，系主任，课程号，成绩），该关系模式的主码是学号+课程号，（学号，课程号）→成绩是完全函数依赖。

**部分函数依赖**

上述例子中，（学号，课程号）→系号就属于部分函数依赖，因为对于系号来说有学号就可以推出系号。

**（6）传递依赖**

上述例子中，学号→系号，系号→系主任名，则称系主任名传递依赖于学号。

**（7）函数依赖的公理系统（Armstrong公理系统）：**

从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则，这些规则常被称作“Armstrong公理”。

设关系式 R(U，F)，U是关系模式 R的属性集，F是 U上的一组函数依赖，则有以下三条推理规则：

1. A1自反律：若 Y⊆X⊆U，则 X→Y为 F所蕴含。
2. A2增广律：若 X→Y为 F所蕴含，且 Z⊆U，则 XZ→YZ为 F所蕴含。
3. A3传递律：若 X→Y，Y→Z为 F所蕴含，则 X→Z为 F所蕴含。根据上面三条推理规则，又可推出下面三条推理规则：
   1. 合并规则：若 X→Y，X→Z，则 X→YZ为 F所蕴含。
   2. 伪传递规则：若 X→Y，WY→Z，则 XW→Z为 F所蕴含。
   3. 分解规则：若 X→Y，Z⊆Y，则 X→Z为 F所蕴含。

**关系数据库的规范化**

关系数据库设计的方法之一就是设计满足适当范式的模式，通常可以通过判断分解后的模式达到几范式来评价模式的规范化程度。

范式包括：1NF、2NF、3NF、BCNF、4NF、5NF。

根据系统架构设计师考试的要求，这里重点介绍 1NF、2NF、3NF、BCNF的基本概念。

第一范式（1NF）：若关系模式 R的每一个分量是不可再分的数据项，则关系模式 R属于第一范式。

第二范式（2NF）：若关系模式 R∈1NF，且每一个非主属性完全依赖主码时，则关系式R是 2NF（第二范式）。

第三范式（3NF）：当 2NF消除了非主属性对主码的传递函数依赖，则称为 3NF。

BC范式（BCNF）：如果关系模式 R∈1NF，且每个属性都不传递依赖于 R的候选码，那么称 R是 BCNF模式。上述 4种范式之间有如下联系：BCNF⊂3NF⊂2NF⊂1NF。

**5．事务管理**

DBMS运行的基本工作单位是事务，事务是用户定义的一个数据库操作序列，这些操作序列要么全做，要么全都不做，是一个不可分割的工作单位。

事务具有的四个特性（ACID）：

1. 原子性（Atomicity）：事务是数据库的逻辑工作单位，事务的所有操作在数据库中要么全做，要么全都不做。
2. 一致性（Consistency）：事务的执行使数据库从一个一致性状态变成另一个一致性状态。
3. 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。
4. 持久性（Durability）：指一个事务一旦提交，它对数据库的改变必须是永久的，即便系统出现故障时也是如此。

**相关的 SQL语句**

BEGIN TRANSACTION：事务开始语句。

COMMIT：事务提交语句，表示事务执行成功地结束，把事务对数据库的修改写入磁盘（事务对数据库的操作首先是在缓冲区中进行的）。

ROLL BACK：事务回滚语句，表示事务执行不成功地结束，即把事务对数据库的修改进行恢复。

**并发控制**

在多用户共享系统中，**许多事务可能同时对同一数据进行操作，称为并发操作**，此时数据库管理系统的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，同时避免用户得到不正确的数据。

并发控制的主要技术是封锁，主要有两种类型的封锁，分别是 X封锁和 S封锁。

**排他型封锁（X封锁）**

如果事务 T对数据 A（可以是数据项、记录、数据集以至整个数据库）实现了 X封锁，那么**只允许事务 T读取和修改数据 A**，**其他事务要等事务 T解除 X封锁以后，才能对数据 A实现任何类型的封锁**。可见 X封锁只允许一个事务独锁某个数据，具有排他性。

**共享型封锁（S封锁）**

如果事务 T对数据 A实现了 S封锁，那么**允许事务 T读取数据A，但不能修改数据 A，在所有 S封锁解除之前决不允许任何事务对数据 A实现 X封锁**。

**数据库的备份与恢复**

备份是指通过数据**转储和监理日志文件的方法监理冗余数据**，DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本。

数据库的恢复是指把数据库从错误状态恢复到某一个已知的正确状态的功能。

当数据库遭到破坏后，就可以利用后备副本把数据库恢复，这时数据库只能恢复到备份时的状态，从那以后的所有更新事务必须重新运行才能恢复到故障时的状态。

备份分类包括以下 4种：

1. 静态备份：指备份期间不允许（或不存在）对数据库进行任何存取、修改活动。静态备份简单，**但备份必须等待用户事务结束才能进行，新的事务必须等待备份结束才能执行。**这降低了数据库的可用性。
2. 动态备份：指备份期间允许对数据库进行存取或修改，即**备份和用户事务可以并发执行**。动态备份可克服静态备份的缺点，但备份结束时后援副本上的数据并不能保证正确有效。
3. 海量备份：指每次备份全部数据库。
4. 增量备份：指每次只备份上次备份后更新过的数据。如果数据库很大，事务处理又十分频繁，则增量备份方式是很有效的。

数据库的 4类故障：

1. 事务故障
2. 系统故障
3. 介质故障
4. 计算机病毒

事务故障的恢复有两个操作：

1. 撤销事务（UNDO）
2. 重做事务（REDO）

介质故障的恢复由数据库管理员装入数据库的副本和日记文件副本，再由系统执行撤销和重做操作。

#### 数据库设计

**数据库设计**

基本步骤可以分为:

1. 用户需求分析
2. 概念结构设计
3. 逻辑结构设计
4. 物理结构设计
5. 应用程序设计
6. 运行维护

**数据需求分析**

用户需求分析是综合各用户的应用需求，对现实世界要处理的对象进行详细调查，在了解先行系统的概况，确定新系统功能的过程中，协助用户明确对新系统的信息要求、处理要求和系统要求，确定新系统的边界。

**概念结构设计**

概念数据模型又称为实体-联系模型，它按照用户的观点来对数据和信息建模，主要用于数据库设计。

概念模型主要用实体-联系方法（Entity-Relationship Approach）表示，简称 E-R方法。

概念结构设计工作步骤包括：

1. 选择局部应用
2. 逐一设计分 E-R图和 E-R图合并

在进行 E-R图合并时，需解决属性冲突命名冲突和结构冲突E-R模型简称 E-R图，是描述概念世界、建立概念模型的实用工具。

E-R图的三个要素有：

1. 实体（型）：用矩形框表示，框内标注实体名称。
2. 属性：用椭圆形表示，并用连线与实体连接起来。
3. 实体之间的联系：用菱形框表示，框内标注联系名称，用连线将菱形框分别与有关实体相连，并在连线上注明联系类型。

**逻辑结构设计**

逻辑结构设计阶段主要工作步骤包括：

1. 确定数据模型
2. 将 E-R图转换成指定的数据模型
3. 确定完整性约束和确定用户视图

**物理设计**

物理设计主要工作步骤包括：

1. 确定数据分布
2. 存储结构
3. 访问方式

**数据库实施**

数据库实施是根据逻辑和物理设计的结果，在计算机上建立实际的数据库结构，数据加载（装入），进行试运行和评价。

**数据库运行维护**

数据库运行维护主要包括：

1. 对数据库性能的监测和改善
2. 故障恢复
3. 数据库的重组和重构。

在数据库运行阶段，对数据库的维护主要由 DBA完成。

**商业智能**

商业智能（Business Intelligence，BI）是企业对商业数据的**搜集、管理和分析**的系统过程，目的是使企业的**各级决策者获得知识或洞察力**，帮助他们作出对企业**更有利的决策**。

三大组成部分：

1. 一般认为数据仓库
2. 联机分析处理（OLAP）
3. 数据挖掘是商业智能的

**数据仓库（Data Warehouse）**

是一个面向主题的、集成的、相对稳定且随时间变化的数据集合，用于支持管理决策。

数据仓库的关键特征是：

1. 面向主题
2. 集成的
3. 非易失的
4. 时变的

| 比较项目     | 传统数据库           | 数据仓库                    |
| -------- | --------------- | ----------------------- |
| 数据内容     | 当前值             | 历史的、归档的、归纳的、计算的数据（处理过的） |
| 数据目标     | 面向业务操作程序、重复操作   | 面向主体域，分析应用              |
| 数据特性     | 动态变化、更新         | 静态、不能直接更新，只能定时添加、更新     |
| 数据结构     | 高度结构化、复杂，适合操作计算 | 简单、适合分析                 |
| 使用频率     | 高               | 低                       |
| 数据访问量    | 每个事务一般只访问少量记录   | 每个事务一般访问大量记录            |
| 对响应时间的要求 | 计时单位小，如秒        | 计时单位相对较大，除了秒，还有分钟、小时    |

8OLTP与 OLAP的比较：OLTP即联机事务处理，就是我们经常说的关系数据库的基础；

OLAP即联机分析处理，是数据仓库的核心部分。

| 项目   | OLTP                | OLAP                |
| ---- | ------------------- | ------------------- |
| 用户   | 操作人员、低层管理人员         | 决策人员、高级管理人员         |
| 功能   | 日常操作处理              | 分析决策                |
| DB设计 | 面向应用                | 面向主题                |
| 数据   | 当前的、最新的、细节的、二维的、分立的 | 历史的、聚集的、多维的、集成的、统一的 |
| 存取   | 读/写数十条记录            | 读上百万条记录             |
| 工作单位 | 简单的事务               | 复杂的查询               |
| 用户数  | 上千个                 | 上百个                 |
| DB大小 | 100MB至 GB级          | 100GB至 TB级          |

**数据挖掘**

数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识。

数据挖掘所得到的信息应三个特征：

1. 具有先知
2. 有效
3. 实用

先前未知的信息是指该信息是预先未曾预料到的，即数据挖掘是要发现那些不能靠直觉发现的信息或知识，甚至是违背直觉的信息或知识，挖掘出的信息越是出乎意料，就可能越有价值。

#### 应用程序与数据库的交互

常见应用程序与数据库交互方式有库函数、嵌入式 SQL、通用数据接口标准和对象关系映射等。

**库函数级别访问接口**

库函数级别的数据访问接口是数据库提供的最底层的高级程序语言访问数据接口，如 Oracle数据库的 Oracle Call Interface（OCI）。OCI由一组应用程序开发接口（API）组成，实际是将结构化查询语言（SQL）和高级语言程序相结合。

其缺点是强依赖于特定的数据库，需数据库开发人员对数据库机制有较深的理解，学习难度较大，开发效率不是很高。

**嵌入式 SQL访问接口**

嵌入式 SQL（Embeded SQL）是一种将 SQL语句直接写入某些高级程序语言源代码中的方法。

通用数据接口标准

开放数据库连接（Open DataBase Connectivity，ODBC）是**为解决异构数据库间的数据共享**产生的。优点是不依赖于任何 DBMS，能以统一的方式处理所有的关系数据库。

常见数据库接口包括：

1. 数据库访问对象（Data Access Object，DAO）
2. 远程数据库对象（Remote Data Object， RDO）
3. ActiveX数据对象（Active Data Object，ADO）
4. Java数据库连接（java DataBase Connection，JDBC）

**ORM访问接口**

对象关系映射（Object Relationship Mapping，ORM）用于实现面向对象编程语言里不同类型系统数据之间的转换。典型的 ORM框架有 Hibernate、Mybatis和 JPA等。

* Hibernate：全自动化的框架，强大、复杂、笨重、学习成本高。
* Mybatis：半自动的框架。
* JPA：Java自带的框架。

#### NoSQL 数据库

NoSQL是一种概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。

NoSQL数据库按照所使用的数据结构的类型，可分为：

1.  **列式存储数据库**

    用来应对分布式存储的海量数据，键仍然存在，

    特点是指向了多个列。

    现有产品如 Cattandra、HBate、Riak。
2.  **键值对存储数据库**

    键值对存储数据库优势是简单、易部署。

    但是只对部分值查询或更新时效率低下。现有产品如 Tokzo Cabinet/Tzranu、Redis、Voldemort、Oracle BDB。
3.  **文档型数据库**

    文档型数据库在处理网页等复杂数据时，比传统键值对数据库查询效率更高。

    现有产品如 CouchDB、MongoDB、SequoiaDB。
4.  **图数据库**

    图数据库适合存储通过图进行建模的数据，如社交网络数据、生物信息网络数据，交通网络数据等。常见产品有 Neo4J、InfoGrid、Infinite Graph等。

NoSQL特征：

1. 易扩展
2. 大数据量
3. 高性能
4. 灵活的数据模型
5. 高可用。

NoSQL整体框架由下至上分为：

1. 数据持久层（Data Persistence）
2. 数据分布层（Data Distribution Model）
3. 数据逻辑模型层（Data Logical Model）
4. 接口层（Interface）

NoSQL数据库适用情况：

1. 数据模型比较简单
2. 需灵活性更强的 IT系统
3. 对数据库性能要求较高
4. 不需要高度的数据一致性

#### 分布式数据库

**体系结构**

分布式数据库的体系结构：

![image-20240513154214519](file:///C:/Users/chenkanglin/Nutstore/1/exem/assets/image-20240513154214519.png?lastModify=1715749652)

全局视图：全局视图（全局外模式）是**全局应用的用户视图**，是全局概念模式的子集，该层**直接与用户（或应用程序）交互**。

全局概念模式：全局概念模式定义分布式数据库中数据的**整体逻辑结构**，数据就**如同根本没有分布一样**，可用传统的集中式数据库中所采用的方法进行定义。

分片模式：将一个关系模式分解成为几个数据片。

分配模式：分布式数据库的本质特性就是数据分布在不同的物理位置。分配模式的主要职责是**定义数据片段（即分片模式的处理结果）的存放节点**。

局部概念模式：局部概念模式是**局部数据库的概念模式**。

局部内模式：局部内模式是**局部数据库的内模式**。

**特点**

分布式数据库具有如下特点：

1. 共享性：不同的节点的数据共享。
2. 自治性：每个节点对本地数据都能独立管理。
3. 可用性：某一场地故障时，可以使用其他场地上的副本而不至于使整个系统瘫痪。
4. 分布性：数据分布在不同场地上存储。

**分布透明性**

分布透明性是指用户不必关心**数据的逻辑分片**，不必关心数据**存储的物理位置**分配细节，也不必关心**局部场地上数据库的数据模型**。

分布透明性包括：

1.  **分片透明性**

    分布透明性的最高层次。

    指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。
2.  **位置透明性**

    分布透明性的下一层次。

    指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。
3.  **局部数据模型透明性**

    指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是**何种数据模型**。

**数据库优化技术**

**集中式数据库优化技术**

集中式数据库性能优化是反规范化设计，包括 ：

1.  **主要包括增加冗余列**

    在多个表中具有相同的列，它常用来在查询时避免连接操作。
2.  **增加派生列**

    增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。
3.  **重新组表**

    如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接，从而提高性能。
4.  **水平分割表**

    按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。
5.  **垂直分割表**

    对表进行分割，将主键与部分列放到一个表中，主键与其他列放到另一个表中，在查询时减少 I/O次数。

反规范化设计的优点是避免进行表之间的连接操作，从而可以提高数据操作的性能；缺点是会造成数据的重复存储，浪费了磁盘空间，会产生数据的不一致性问题。

若要避免数据不一致的问题，可以通过设置触发器、采用事务机制（适用于单体数据库中）、应用保证（适用于异构数据库之间）以及批处理脚本的方式，这些方式的优缺点这里不再赘述。

**分布式数据库优化技术**

分布式数据库的性能优化可以采用：

1.  **主从复制**

    建立一个和主数据库完全一样的数据库环境，称为从数据库。

    好处：

    1. 做数据的热备。作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
    2. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘 I/O访问的频率，提高单个机器的 I/O性能。
    3.  读写分离。使数据库能支持更大的并发。

        在 MySQL数据库中，主从数据库同步的模式有三种方式：

        1. 全同步
        2. 半同步
        3. 异步

    主从数据库之间通过 binlog（二进制日志）进行数据的同步。

    ![image-20240513135620284](file:///C:/Users/chenkanglin/Nutstore/1/exem/assets/image-20240513135620284.png?lastModify=1715749652)

    binlog日志有 3种模式：

    1.  基于 SQL语句的复制

        每一条更新的语句（insert、update、delete）都会记录在 binlog中，进而同步到从库的 relaylog中，被从库的 SQL线程取出来，回放执行。

        该模式的优点是 binlog的日志量可能会比较少，比如一个涉及行数为 1000行的 update语句，同步这一个语句，就同步了 1000行的数据。

        缺点是同步的 SQL语句里如果含有绑定本地变量的函数、关键字，可能造成主从不一致的情况。比如 SQL语句中有 time函数，如果主从数据库的服务器时间不是精确相等，就会造成结果不一致。
    2.  基于行的复制

        不记录 SQL语句，只记录哪个记录更新前和更新后的数据，可以保证主从之间的数据绝对相同。

        缺点是：1条 SQL更新 1000行的数据无法再偷懒，必须原原本本同步 1000行的数据量。
    3.  混合复制

        以上两种模式的混合，选取两者的优点。

        对于有绑定本地特性、评估可能造成主从不一致的 SQL语句，则自动选用基于行的复制，其他的选择基于 SQL语句的复制。
2.  **读写分离**

    设置不同的主、从数据库分别负责不同的操作。让主数据库负责数据的写操作，从数据库负责数据的读操作。通过角色分担的策略，分别提升读写性能，有效减少数据并发操作的延迟。
3.  **分表**

    分表也叫分片，可以提升数据库并发以及 I/O的性能。分表重在单个实例内部，将一张大表分成若干小表，业务同时访问多个表。

    1.  垂直切分

        把一个大表切分为多个表。例如交易 ID、状态、用户、金额、商品等，作为一个热表；另外的交易备注、物流信息等众多其他属性可作为另一个表。
    2.  水平切分

        把一个大表分为多个表，每个表都包含相同列，例如交易 ID、状态、用户、金额、商品等，但都包含不同的行。例如一个表包含的是交易 ID从 1到 999999的交易数据，另一个表包含的是交易 ID从 1000000到 9999999的交易数
4.  **分库**

    分库是将原本存放在一个实例上众多分类的数据（表），分开存放到不同的实例上。有利于差异化管理。

    例如，一个简单的电商网站，包括用户、商品、订单三个业务模块，可以将用户数据、商品数据、订单数据分开放到三台不同的数据库服务器上，而不是将所有数据都放在一台数据库服务器上。

#### 分布式缓存技术 Redis

Redis是一种分布式缓存技术，也是一种键值对数据库类型。

Redis用作缓存组件时，其基于内存的读写特性，比基于磁盘读写的数据库性能要高很多，适合缓存高频热点的数据，来提高读性能。这样可以降低对数据库服务器的查询请求，提高系统性能。

Redis以 key-value（键值对）的形式为数据的保存格式。

键（key）可以是一个字符串，值（value）可以是任意类型的数据。如整型、字符型、数组、列表、集合等。

**数据类型**

Redis支持的数据类型主要包括：

1. string类型。可用于缓存层或计数器，如视频播放量、文章浏览量等。
2. hash类型。代替 string类型，节省空间。描述用户信息较为方便。
3. set类型。无序集合，每个值不能重复。可用于去重、抽奖、初始化用户池等。
4. list类型。双向链表结构，可以模拟栈、队列等形式。可用于回复评论、点赞。
5. zset类型。有序集合、每个元素有一个分数。如首页推荐 10个最热门的帖子。
6. pub/sub类型。

**访问方式**

引入 Redis后，热点数据存放在 Redis中，但由于存在“一份数据存放了多个位置”，所以要考虑数据的一致性问题。读写数据的基本步骤为：

* 读数据：
  1. 根据 key读缓存
  2. 读取成功则直接返回
  3. 若 key不在缓存中，则根据 key读数据库
  4. 读取成功后，写缓存
  5. 成功返回
* 写数据：
  1. 根据 key值写数据库
  2. 成功后更新缓存 key值
  3. 成功返回

**过期策略**

在使用 Redis时，一般会设置 Redis缓存空间的大小，不会让数据无限制地存放到 Redis中，对于设置了过期时间的数据可以采用两种方式去淘汰这些数据。

**定期删除**

Redis每隔一段时间就会抽取一些设置了过期时间的 key。这里的抽取是随机进行的，因为无法对所有的 key进行遍历，会给系统带来很大的负担。但是这样也会导致一些 key到了过期时间也仍然没有被删除。

**惰性删除**

查询 key的时候 Redis会对 key进行检测，发现如果已经达到过期时间，则删除。

惰性删除的缺点是如果这些过期的 key没有被访问，那么它们就一直无法被删除，而且一直占用内存。

除了上述两种方式，Redis又提供了一些淘汰机制，主要有：

1. volatile-lru（最近最少使用）：从已设置过期时间的 key中，移出最近最少使用的 key进行淘汰。
2. volatile-lfu（最不经常使用）：从 key中选择最不经常使用的进行淘汰。
3. volatile-random（随机淘汰算法）：从已设置过期时间的 key中随机选择 key淘汰。
4. volatile-ttl（生存时间淘汰）：从已设置过期时间的 key中，移出将要过期的 key。
5. allkeys-lru：从所有 key中选择最近最少使用的进行淘汰。
6. allkeys-lfu：从所有 key中选择最不经常使用的进行淘汰。
7. allkeys-random：从所有 key中随机选择 key进行淘汰。

**数据持久化**

在实际应用中，一旦服务器宕机，内存中的数据将全部丢失。

我们很容易想到的一个解决方案是，从后端数据库恢复这些数据，但这种方式存在两个问题：一是，需要频繁访问数据库，会给数据库带来巨大的压力；二是，这些数据是从慢速数据库中读取出来的，性能肯定比不上从Redis中读取来得快，这会导致使用这些数据的应用程序响应变慢。所以，对 Redis来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。

Redis数据持久化的方式有两种:

* RDB内存快照（Redis Data Base），把当前内存中的数据集快照写入磁盘（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里
* AOF日志（Append Only File），通过持续不断地保存 Redis服务器所执行的更新命令来记录数据库状态，类似 MySQL的binlog日志。恢复数据时需要从头开始回放更新命令

| 项目     | RDB内存快照 | AOF日 |
| ------ | ------- | ---- |
| 磁盘刷新频率 | 低       | 高    |
| 文件大小   | 小       | 大    |
| 数据恢复效率 | 高       | 低    |
| 数据安全   | 低       | 高    |

**缓存穿透**

大量请求访问了没有缓存的 key，即**大量的 key在 Redis里是不存在的**，从而导致请求直接访问数据库，数据库压力增大。

可能的原因如下：

1.  恶意攻击，造成大量访问不存在的 key。

    例如登录时使用无效的用户名，在软考网站查询成绩时输入不存在的身份证号、准考证号。

    解决方案：

    1. 针对比较少的请求来源 IP，主动限制其访问次数，或者拉入黑名单；
    2. 应用程序来检查 key的合法性，提前拒绝不合法的请求；
    3. 使用布隆过滤器。
2.  大量请求访问数据库里有但 Redis没有的 key。

    例如新业务刚刚上线，此时 Redis是空的。

    解决方案：

    1. 预热 Redis，运行一个批处理脚本，将可能会大量访问的数据预先加载到 Redis，业务再“开张”；
    2. 在最前端进行流量控制，逐步把请求释放进来。给出一段时间，让 Redis逐步加载热数据；
    3. 如果是在数据库里也没有的 key，也需要在 Redis中设置 key，使其值为 null或空。

**缓存雪崩**

大量请求访问到缓存中的 key，这些 key是存在的，但**同时到了过期时间**，从而导致请求直接访问数据库，数据库压力增大。**缓存雪崩可能进而影响一系列的雪崩，影响到上下游的所有应用服务**。

可能的原因如下：

1.  Redis故障。

    比如 Redis宕机，网络出现抖动等。

    解决方案：

    1. 使用主从复制提高可用性，使用 cluster集群方案降低故障时影响的范围；
    2. 如果出现故障，则可以采取服务降级、熔断、限流等措施。
2.  大量的 key采用了相同的过期时间。

    例如在同一时刻设置了大量的 key，但过期时间都是 5分钟。

    解决方案：

    1. 过期时间加上一个随机值，使得众多 key均匀过期。

**缓存击穿**

**少量热点的 key缓存时间失效了**，使得请求直接访问数据库。

可能的原因：

1.  热点的 key设置了太短的过期时间。

    例如秒杀业务下的“库存数量”。

    解决方案：

    1. 将 key设置较长的过期时间。对于非常重要的 key，则设置永久有效。但需要解决好与数据库中的 key的一致性问题；
    2. 使用分布式锁。如果热点 key失效了，要控制好访问后端数据库的流量。只允许一个请求去访问数据库，取出最新的 key，存放到 Redis，其他请求则必须等待。但分布式锁也要防止出现异常的情况。

**Redis集群**

Redis也可以采用集群的方式部署，主要有：

* 主从复制集群
* 哨兵集群
* Cluster集群方式

集群切片的方式主要分为三种方式：

1. 客户端分片
2. 代理分片
3. 服务器端分片

\
